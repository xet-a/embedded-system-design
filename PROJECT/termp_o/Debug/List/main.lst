###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       13/Dec/2022  22:22:14
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu6\Downloads\embedded_system_design-lab\PROJECT\termp_o\user\main.c
#    Command line =  
#        -f C:\Users\pnu6\AppData\Local\Temp\EW1FA.tmp
#        (C:\Users\pnu6\Downloads\embedded_system_design-lab\PROJECT\termp_o\user\main.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu6\Downloads\embedded_system_design-lab\PROJECT\termp_o\Debug\List
#        -o
#        C:\Users\pnu6\Downloads\embedded_system_design-lab\PROJECT\termp_o\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu6\Downloads\embedded_system_design-lab\PROJECT\termp_o\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu6\Downloads\embedded_system_design-lab\PROJECT\termp_o\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu6\Downloads\embedded_system_design-lab\PROJECT\termp_o\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu6\Downloads\embedded_system_design-lab\PROJECT\termp_o\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I
#        C:\Users\pnu6\Downloads\embedded_system_design-lab\PROJECT\termp_o\user\
#        -I
#        C:\Users\pnu6\Downloads\embedded_system_design-lab\PROJECT\termp_o\user\inc\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu6\Downloads\embedded_system_design-lab\PROJECT\termp_o\Debug\List\main.lst
#    Object file  =  
#        C:\Users\pnu6\Downloads\embedded_system_design-lab\PROJECT\termp_o\Debug\Obj\main.o
#
###############################################################################

C:\Users\pnu6\Downloads\embedded_system_design-lab\PROJECT\termp_o\user\main.c
      1          #include "common.h"
      2          #include "servo.h"
      3          #include "game.h"
      4          #include "bluetooth.h"
      5          #include "light.h"
      6          #include "motor.h"
      7          
      8          

   \                                 In section .text, align 2, keep-with-next
      9          void delay(int d){
     10            for (int i = 0; i <= d; i++) {
   \                     delay: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE000             B.N      ??delay_0
   \                     ??delay_1: (+1)
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \                     ??delay_0: (+1)
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xDAFC             BGE.N    ??delay_1
     11                ;
     12            }
     13          } 
   \   0000000A   0x4770             BX       LR               ;; return
     14          

   \                                 In section .data, align 4
     15          uint16_t light_num[4] = {
   \                     light_num:
   \   00000000   0x0100 0x0200      DC16 256, 512, 1024, 2048
   \              0x0400 0x0800
     16              GPIO_Pin_8,
     17              GPIO_Pin_9,
     18              GPIO_Pin_10,
     19              GPIO_Pin_11
     20          };

   \                                 In section .data, align 2
     21          uint16_t motor_num = GPIO_Pin_2;
   \                     motor_num:
   \   00000000   0x0004             DC16 4
     22          

   \                                 In section .bss, align 4
     23          volatile uint32_t ADC_Value[3];
   \                     ADC_Value:
   \   00000000                      DS8 12

   \                                 In section .bss, align 4
     24          GameStatus gameStatus;
   \                     gameStatus:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     25          uint16_t scoreResult[8];
   \                     scoreResult:
   \   00000000                      DS8 16
     26          
     27          
     28          

   \                                 In section .text, align 2, keep-with-next
     29          void getDecStr(uint16_t* str, uint16_t val){
   \                     getDecStr: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0002             MOVS     R2,R0
     30            uint16_t i;
     31            uint16_t len = 0;
   \   00000004   0x2300             MOVS     R3,#+0
     32            
     33            uint16_t valCopy = val;
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0xE004             B.N      ??getDecStr_0
     34            
     35            while (valCopy > 0) {
     36              len++;
   \                     ??getDecStr_1: (+1)
   \   0000000A   0x1C5B             ADDS     R3,R3,#+1
     37              valCopy /= 10;
   \   0000000C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000E   0x200A             MOVS     R0,#+10
   \   00000010   0xFB94 0xF4F0      SDIV     R4,R4,R0
     38            }
   \                     ??getDecStr_0: (+1)
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD1F6             BNE.N    ??getDecStr_1
     39            
     40            for(i=1; i<=len; i++){
   \   0000001C   0x2401             MOVS     R4,#+1
   \   0000001E   0xE014             B.N      ??getDecStr_2
     41              str[len-i] = (uint8_t) ((val % 10UL) + '0');
   \                     ??getDecStr_3: (+1)
   \   00000020   0x000D             MOVS     R5,R1
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0x260A             MOVS     R6,#+10
   \   00000026   0x001F             MOVS     R7,R3
   \   00000028   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002E   0x1A3F             SUBS     R7,R7,R0
   \   00000030   0xFBB5 0xF0F6      UDIV     R0,R5,R6
   \   00000034   0xFB06 0x5510      MLS      R5,R6,R0,R5
   \   00000038   0x3530             ADDS     R5,R5,#+48
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0xF822 0x5017      STRH     R5,[R2, R7, LSL #+1]
     42              val/=10;
   \   00000040   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000042   0x200A             MOVS     R0,#+10
   \   00000044   0xFB91 0xF1F0      SDIV     R1,R1,R0
     43            }
   \   00000048   0x1C64             ADDS     R4,R4,#+1
   \                     ??getDecStr_2: (+1)
   \   0000004A   0x0018             MOVS     R0,R3
   \   0000004C   0x0025             MOVS     R5,R4
   \   0000004E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000050   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000052   0x42A8             CMP      R0,R5
   \   00000054   0xD2E4             BCS.N    ??getDecStr_3
     44          
     45            str[i-1] = '\0';
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000005A   0xEB02 0x0144      ADD      R1,R2,R4, LSL #+1
   \   0000005E   0xF821 0x0C02      STRH     R0,[R1, #-2]
     46          }
   \   00000062   0xBCF0             POP      {R4-R7}
   \   00000064   0x4770             BX       LR               ;; return
     47          
     48          /* ========================= SERVO ========================= */
     49          
     50          

   \                                 In section .bss, align 4
     51          PWM pwm;
   \                     pwm:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
     52          PWM pwm2;
   \                     pwm2:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
     53          PWM pwm3;
   \                     pwm3:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
     54          PWM pwm4;
   \                     pwm4:
   \   00000000                      DS8 28
     55          

   \                                 In section .text, align 2, keep-with-next
     56          static void pwm_setting(){
   \                     pwm_setting: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     57              pwm.OCMode     = TIM_OCMode_PWM1;
   \   00000002   0x2060             MOVS     R0,#+96
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000008   0x8088             STRH     R0,[R1, #+4]
     58              pwm.rcc_timer    = RCC_APB1Periph_TIM4;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000010   0x6088             STR      R0,[R1, #+8]
     59              pwm.timer           = TIM4;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40000800
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000001A   0x60C8             STR      R0,[R1, #+12]
     60              pwm.rcc_gpio     = RCC_APB2Periph_GPIOB;
   \   0000001C   0x2008             MOVS     R0,#+8
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000022   0x6108             STR      R0,[R1, #+16]
     61              pwm.gpio_port    = GPIOB;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40010c00
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000002C   0x6148             STR      R0,[R1, #+20]
     62              pwm.gpio_pin     = GPIO_Pin_8;
   \   0000002E   0xF44F 0x7080      MOV      R0,#+256
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000036   0x8308             STRH     R0,[R1, #+24]
     63              pwm.channel      = 3;
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000003E   0x6008             STR      R0,[R1, #+0]
     64              SERVO_Configure(&pwm);
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   00000044   0x.... 0x....      BL       SERVO_Configure
     65              SERVO_Rotate(&pwm, 90);
   \   00000048   0x215A             MOVS     R1,#+90
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   0000004E   0x.... 0x....      BL       SERVO_Rotate
     66              
     67              pwm2.OCMode    = TIM_OCMode_PWM1;
   \   00000052   0x2060             MOVS     R0,#+96
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   00000058   0x8088             STRH     R0,[R1, #+4]
     68              pwm2.rcc_timer   = RCC_APB1Periph_TIM4;
   \   0000005A   0x2004             MOVS     R0,#+4
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   00000060   0x6088             STR      R0,[R1, #+8]
     69              pwm2.timer          = TIM4;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40000800
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   0000006A   0x60C8             STR      R0,[R1, #+12]
     70              pwm2.rcc_gpio    = RCC_APB2Periph_GPIOB;
   \   0000006C   0x2008             MOVS     R0,#+8
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   00000072   0x6108             STR      R0,[R1, #+16]
     71              pwm2.gpio_port   = GPIOB;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40010c00
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   0000007C   0x6148             STR      R0,[R1, #+20]
     72              pwm2.gpio_pin    = GPIO_Pin_9;
   \   0000007E   0xF44F 0x7000      MOV      R0,#+512
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   00000086   0x8308             STRH     R0,[R1, #+24]
     73              pwm2.channel     = 4;
   \   00000088   0x2004             MOVS     R0,#+4
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   0000008E   0x6008             STR      R0,[R1, #+0]
     74              SERVO_Configure(&pwm2);
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable12_5
   \   00000094   0x.... 0x....      BL       SERVO_Configure
     75              SERVO_Rotate(&pwm2, 150);
   \   00000098   0x2196             MOVS     R1,#+150
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable12_5
   \   0000009E   0x.... 0x....      BL       SERVO_Rotate
     76              
     77              pwm3.OCMode    = TIM_OCMode_PWM1;
   \   000000A2   0x2060             MOVS     R0,#+96
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000A8   0x8088             STRH     R0,[R1, #+4]
     78              pwm3.rcc_timer   = RCC_APB1Periph_TIM4;
   \   000000AA   0x2004             MOVS     R0,#+4
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000B0   0x6088             STR      R0,[R1, #+8]
     79              pwm3.timer          = TIM4;
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40000800
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000BA   0x60C8             STR      R0,[R1, #+12]
     80              pwm3.rcc_gpio    = RCC_APB2Periph_GPIOB;
   \   000000BC   0x2008             MOVS     R0,#+8
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000C2   0x6108             STR      R0,[R1, #+16]
     81              pwm3.gpio_port   = GPIOB;
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40010c00
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000CC   0x6148             STR      R0,[R1, #+20]
     82              pwm3.gpio_pin    = GPIO_Pin_6;
   \   000000CE   0x2040             MOVS     R0,#+64
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000D4   0x8308             STRH     R0,[R1, #+24]
     83              pwm3.channel     = 1;
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000DC   0x6008             STR      R0,[R1, #+0]
     84              SERVO_Configure(&pwm3);
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable12_6
   \   000000E2   0x.... 0x....      BL       SERVO_Configure
     85              
     86              pwm4.OCMode    = TIM_OCMode_PWM1;
   \   000000E6   0x2060             MOVS     R0,#+96
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable12_7
   \   000000EC   0x8088             STRH     R0,[R1, #+4]
     87              pwm4.rcc_timer   = RCC_APB1Periph_TIM4;
   \   000000EE   0x2004             MOVS     R0,#+4
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable12_7
   \   000000F4   0x6088             STR      R0,[R1, #+8]
     88              pwm4.timer          = TIM4;
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40000800
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable12_7
   \   000000FE   0x60C8             STR      R0,[R1, #+12]
     89              pwm4.rcc_gpio    = RCC_APB2Periph_GPIOB;
   \   00000100   0x2008             MOVS     R0,#+8
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable12_7
   \   00000106   0x6108             STR      R0,[R1, #+16]
     90              pwm4.gpio_port   = GPIOB;
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40010c00
   \   0000010C   0x.... 0x....      LDR.W    R1,??DataTable12_7
   \   00000110   0x6148             STR      R0,[R1, #+20]
     91              pwm4.gpio_pin    = GPIO_Pin_7;
   \   00000112   0x2080             MOVS     R0,#+128
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable12_7
   \   00000118   0x8308             STRH     R0,[R1, #+24]
     92              pwm4.channel     = 2;
   \   0000011A   0x2002             MOVS     R0,#+2
   \   0000011C   0x.... 0x....      LDR.W    R1,??DataTable12_7
   \   00000120   0x6008             STR      R0,[R1, #+0]
     93              SERVO_Configure(&pwm4);
   \   00000122   0x.... 0x....      LDR.W    R0,??DataTable12_7
   \   00000126   0x.... 0x....      BL       SERVO_Configure
     94          }
   \   0000012A   0xBD01             POP      {R0,PC}          ;; return
     95          
     96          
     97          
     98          /* ========================= GAME ========================= */
     99          

   \                                 In section .text, align 2, keep-with-next
    100          void GAME_init(){
    101              gameStatus.start = 0;
   \                     GAME_init: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   00000006   0x6008             STR      R0,[R1, #+0]
    102              // led ???? ???
    103          }
   \   00000008   0x4770             BX       LR               ;; return
    104          

   \                                 In section .text, align 2, keep-with-next
    105          void GAME_start(){
   \                     GAME_start: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    106              if (gameStatus.start != 1){
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable12_8
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD015             BEQ.N    ??GAME_start_0
    107                  gameStatus.start = 1;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   00000012   0x6008             STR      R0,[R1, #+0]
    108                  gameStatus.score = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   0000001A   0x6048             STR      R0,[R1, #+4]
    109                  
    110                  SERVO_Rotate(&pwm4, 180);
   \   0000001C   0x21B4             MOVS     R1,#+180
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable12_7
   \   00000022   0x.... 0x....      BL       SERVO_Rotate
    111                  delay(1000);
   \   00000026   0xF44F 0x707A      MOV      R0,#+1000
   \   0000002A   0x.... 0x....      BL       delay
    112                  SERVO_Rotate(&pwm4, 0);
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable12_7
   \   00000034   0x.... 0x....      BL       SERVO_Rotate
    113                  
    114                  // led ???? ???
    115              }
    116          }
   \                     ??GAME_start_0: (+1)
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
    117          

   \                                 In section .text, align 2, keep-with-next
    118          void GAME_end(){
   \                     GAME_end: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    119              if (gameStatus.start != 0){
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable12_8
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD008             BEQ.N    ??GAME_end_0
    120                  USART_SendData(USART2, 'e');
   \   0000000C   0x2165             MOVS     R1,#+101
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable12_9  ;; 0x40004400
   \   00000012   0x.... 0x....      BL       USART_SendData
    121                  gameStatus.start = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    122                  
    123                  // led ???? ???
    124              }
    125          }
   \                     ??GAME_end_0: (+1)
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
    126          
    127          
    128          /* ========================== BT ==========================*/
    129          

   \                                 In section .bss, align 2
    130          BTConfig BT;
   \                     BT:
   \   00000000                      DS8 2
    131          
    132          // USART Interrupt Handler
    133          

   \                                 In section .text, align 2, keep-with-next
    134          void USART1_IRQHandler() {
   \                     USART1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    135              uint16_t word;
    136              if(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET){
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40013800
   \   0000000A   0x.... 0x....      BL       USART_GetITStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD00F             BEQ.N    ??USART1_IRQHandler_0
    137              // the most recent received data by the USART1 peripheral
    138              word = USART_ReceiveData(USART1);
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40013800
   \   00000016   0x.... 0x....      BL       USART_ReceiveData
   \   0000001A   0x0001             MOVS     R1,R0
    139              
    140              // ??->?????? ?????? (????)
    141              USART_SendData(USART2, word);
   \   0000001C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable12_9  ;; 0x40004400
   \   00000022   0x.... 0x....      BL       USART_SendData
    142          
    143              // clear 'Read data register not empty' flag
    144              USART_ClearITPendingBit(USART1,USART_IT_RXNE);
   \   00000026   0xF240 0x5125      MOVW     R1,#+1317
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable12_10  ;; 0x40013800
   \   0000002E   0x.... 0x....      BL       USART_ClearITPendingBit
    145              }
    146          }
   \                     ??USART1_IRQHandler_0: (+1)
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
    147          

   \                                 In section .text, align 2, keep-with-next
    148          void USART2_IRQHandler(){
   \                     USART2_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    149              uint16_t word;
    150              if(USART_GetITStatus(USART2,USART_IT_RXNE)!=RESET){
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x....             LDR.N    R0,??DataTable12_9  ;; 0x40004400
   \   00000008   0x.... 0x....      BL       USART_GetITStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD046             BEQ.N    ??USART2_IRQHandler_0
    151                
    152              word = USART_ReceiveData(USART2);
   \   00000010   0x....             LDR.N    R0,??DataTable12_9  ;; 0x40004400
   \   00000012   0x.... 0x....      BL       USART_ReceiveData
   \   00000016   0x0004             MOVS     R4,R0
    153              if (word == 'a') {
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001C   0x2861             CMP      R0,#+97
   \   0000001E   0xD107             BNE.N    ??USART2_IRQHandler_1
    154                printf("a\n");
   \   00000020   0x....             ADR.N    R0,??DataTable9  ;; 0x61, 0x0A, 0x00, 0x00
   \   00000022   0x.... 0x....      BL       printf
    155                SERVO_Rotate(&pwm, 0);
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x....             LDR.N    R0,??DataTable12_2
   \   0000002A   0x.... 0x....      BL       SERVO_Rotate
   \   0000002E   0xE02C             B.N      ??USART2_IRQHandler_2
    156              }
    157              else if (word == 'b') {
   \                     ??USART2_IRQHandler_1: (+1)
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000034   0x2862             CMP      R0,#+98
   \   00000036   0xD107             BNE.N    ??USART2_IRQHandler_3
    158                printf("b\n");
   \   00000038   0x....             ADR.N    R0,??DataTable10  ;; 0x62, 0x0A, 0x00, 0x00
   \   0000003A   0x.... 0x....      BL       printf
    159                SERVO_Rotate(&pwm, 90);
   \   0000003E   0x215A             MOVS     R1,#+90
   \   00000040   0x....             LDR.N    R0,??DataTable12_2
   \   00000042   0x.... 0x....      BL       SERVO_Rotate
   \   00000046   0xE020             B.N      ??USART2_IRQHandler_2
    160              }
    161              else if (word == 'c') {
   \                     ??USART2_IRQHandler_3: (+1)
   \   00000048   0x0020             MOVS     R0,R4
   \   0000004A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000004C   0x2863             CMP      R0,#+99
   \   0000004E   0xD107             BNE.N    ??USART2_IRQHandler_4
    162                printf("c\n");
   \   00000050   0x....             ADR.N    R0,??DataTable11  ;; 0x63, 0x0A, 0x00, 0x00
   \   00000052   0x.... 0x....      BL       printf
    163                SERVO_Rotate(&pwm2, 250);
   \   00000056   0x21FA             MOVS     R1,#+250
   \   00000058   0x....             LDR.N    R0,??DataTable12_5
   \   0000005A   0x.... 0x....      BL       SERVO_Rotate
   \   0000005E   0xE014             B.N      ??USART2_IRQHandler_2
    164              }
    165              else if (word == 'd') {
   \                     ??USART2_IRQHandler_4: (+1)
   \   00000060   0x0020             MOVS     R0,R4
   \   00000062   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000064   0x2864             CMP      R0,#+100
   \   00000066   0xD107             BNE.N    ??USART2_IRQHandler_5
    166                printf("d\n");
   \   00000068   0x....             ADR.N    R0,??DataTable11_1  ;; 0x64, 0x0A, 0x00, 0x00
   \   0000006A   0x.... 0x....      BL       printf
    167                SERVO_Rotate(&pwm2, 150);
   \   0000006E   0x2196             MOVS     R1,#+150
   \   00000070   0x....             LDR.N    R0,??DataTable12_5
   \   00000072   0x.... 0x....      BL       SERVO_Rotate
   \   00000076   0xE008             B.N      ??USART2_IRQHandler_2
    168              }
    169              /*else if (word == 's') {
    170                printf("game score : %d\n", gameStatus.score);
    171                USART_SendData(USART2, gameStatus.score);
    172              }*/
    173              else if (word == 'k') {
   \                     ??USART2_IRQHandler_5: (+1)
   \   00000078   0x0020             MOVS     R0,R4
   \   0000007A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000007C   0x286B             CMP      R0,#+107
   \   0000007E   0xD104             BNE.N    ??USART2_IRQHandler_2
    174                printf("start button\n");
   \   00000080   0x....             LDR.N    R0,??DataTable12_11
   \   00000082   0x.... 0x....      BL       printf
    175                GAME_start();
   \   00000086   0x.... 0x....      BL       GAME_start
    176              }
    177              
    178              USART_SendData(USART1, word);
   \                     ??USART2_IRQHandler_2: (+1)
   \   0000008A   0x0021             MOVS     R1,R4
   \   0000008C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000008E   0x....             LDR.N    R0,??DataTable12_10  ;; 0x40013800
   \   00000090   0x.... 0x....      BL       USART_SendData
    179              USART_ClearITPendingBit(USART2,USART_IT_RXNE);
   \   00000094   0xF240 0x5125      MOVW     R1,#+1317
   \   00000098   0x....             LDR.N    R0,??DataTable12_9  ;; 0x40004400
   \   0000009A   0x.... 0x....      BL       USART_ClearITPendingBit
    180              }
    181          }
   \                     ??USART2_IRQHandler_0: (+1)
   \   0000009E   0xBD10             POP      {R4,PC}          ;; return
    182          
    183          
    184          /* ========================= SENSOR ========================= */
    185          

   \                                 In section .text, align 2, keep-with-next
    186          void sensor_RCC_Configure() {
   \                     sensor_RCC_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    187            RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF44F 0x7000      MOV      R0,#+512
   \   00000008   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    188            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x2008             MOVS     R0,#+8
   \   00000010   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    189            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x2004             MOVS     R0,#+4
   \   00000018   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    190            // RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
    191            // DMA port clock enable
    192            RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x.... 0x....      BL       RCC_AHBPeriphClockCmd
    193          }
   \   00000024   0xBD01             POP      {R0,PC}          ;; return
    194          

   \                                 In section .text, align 2, keep-with-next
    195          void sensor_GPIO_Configure() {
   \                     sensor_GPIO_Configure: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    196            GPIO_InitTypeDef GPIO_InitStructure;
    197            GPIO_InitTypeDef GPIO_InitStructure_A;
    198            
    199            // ADC Port Configure
    200            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
   \   00000002   0x2003             MOVS     R0,#+3
   \   00000004   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    201            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0007      STRB     R0,[SP, #+7]
    202            GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   0000000E   0xA901             ADD      R1,SP,#+4
   \   00000010   0x....             LDR.N    R0,??DataTable12_4  ;; 0x40010c00
   \   00000012   0x.... 0x....      BL       GPIO_Init
    203            
    204            GPIO_InitStructure_A.GPIO_Pin = GPIO_Pin_0;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    205            GPIO_InitStructure_A.GPIO_Mode = GPIO_Mode_AIN;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    206            GPIO_Init(GPIOA, &GPIO_InitStructure_A);
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x....             LDR.N    R0,??DataTable12_12  ;; 0x40010800
   \   00000026   0x.... 0x....      BL       GPIO_Init
    207          }
   \   0000002A   0xBD07             POP      {R0-R2,PC}       ;; return
    208          

   \                                 In section .text, align 2, keep-with-next
    209          void sensor_ADC_Configure() {
   \                     sensor_ADC_Configure: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    210            ADC_InitTypeDef ADC_InitStructure;
    211            
    212            // ADC Configure
    213            ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
    214            ADC_InitStructure.ADC_ScanConvMode = ENABLE;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    215            ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF88D 0x0005      STRB     R0,[SP, #+5]
    216            ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
   \   00000014   0xF45F 0x2060      MOVS     R0,#+917504
   \   00000018   0x9002             STR      R0,[SP, #+8]
    217            ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9003             STR      R0,[SP, #+12]
    218            ADC_InitStructure.ADC_NbrOfChannel = 3;
   \   0000001E   0x2003             MOVS     R0,#+3
   \   00000020   0xF88D 0x0010      STRB     R0,[SP, #+16]
    219            
    220            ADC_Init(ADC1, &ADC_InitStructure);
   \   00000024   0x4669             MOV      R1,SP
   \   00000026   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40012400
   \   00000028   0x.... 0x....      BL       ADC_Init
    221            
    222            ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 1, ADC_SampleTime_239Cycles5);
   \   0000002C   0x2307             MOVS     R3,#+7
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0x2108             MOVS     R1,#+8
   \   00000032   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40012400
   \   00000034   0x.... 0x....      BL       ADC_RegularChannelConfig
    223            ADC_RegularChannelConfig(ADC1, ADC_Channel_9, 2, ADC_SampleTime_239Cycles5);
   \   00000038   0x2307             MOVS     R3,#+7
   \   0000003A   0x2202             MOVS     R2,#+2
   \   0000003C   0x2109             MOVS     R1,#+9
   \   0000003E   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40012400
   \   00000040   0x.... 0x....      BL       ADC_RegularChannelConfig
    224            ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 3, ADC_SampleTime_239Cycles5);
   \   00000044   0x2307             MOVS     R3,#+7
   \   00000046   0x2203             MOVS     R2,#+3
   \   00000048   0x210A             MOVS     R1,#+10
   \   0000004A   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40012400
   \   0000004C   0x.... 0x....      BL       ADC_RegularChannelConfig
    225            
    226            // Enable interrupt
    227            ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);
   \   00000050   0x2201             MOVS     R2,#+1
   \   00000052   0xF44F 0x7108      MOV      R1,#+544
   \   00000056   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40012400
   \   00000058   0x.... 0x....      BL       ADC_ITConfig
    228            ADC_DMACmd(ADC1, ENABLE);
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40012400
   \   00000060   0x.... 0x....      BL       ADC_DMACmd
    229            
    230            // Enable ADC1
    231            ADC_Cmd(ADC1, ENABLE);
   \   00000064   0x2101             MOVS     R1,#+1
   \   00000066   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40012400
   \   00000068   0x.... 0x....      BL       ADC_Cmd
    232            ADC_ResetCalibration(ADC1);
   \   0000006C   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40012400
   \   0000006E   0x.... 0x....      BL       ADC_ResetCalibration
    233            
    234            printf("1\n");
   \   00000072   0x....             ADR.N    R0,??DataTable12  ;; 0x31, 0x0A, 0x00, 0x00
   \   00000074   0x.... 0x....      BL       printf
    235            
    236            while(ADC_GetResetCalibrationStatus(ADC1));
   \                     ??sensor_ADC_Configure_0: (+1)
   \   00000078   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40012400
   \   0000007A   0x.... 0x....      BL       ADC_GetResetCalibrationStatus
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD1FA             BNE.N    ??sensor_ADC_Configure_0
    237            
    238            printf("2\n");
   \   00000082   0x....             ADR.N    R0,??DataTable12_1  ;; 0x32, 0x0A, 0x00, 0x00
   \   00000084   0x.... 0x....      BL       printf
    239            
    240            ADC_StartCalibration(ADC1);
   \   00000088   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40012400
   \   0000008A   0x.... 0x....      BL       ADC_StartCalibration
    241            
    242            while(ADC_GetCalibrationStatus(ADC1));
   \                     ??sensor_ADC_Configure_1: (+1)
   \   0000008E   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40012400
   \   00000090   0x.... 0x....      BL       ADC_GetCalibrationStatus
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD1FA             BNE.N    ??sensor_ADC_Configure_1
    243            
    244            ADC_SoftwareStartConvCmd(ADC1, ENABLE);
   \   00000098   0x2101             MOVS     R1,#+1
   \   0000009A   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40012400
   \   0000009C   0x.... 0x....      BL       ADC_SoftwareStartConvCmd
    245          }
   \   000000A0   0xB005             ADD      SP,SP,#+20
   \   000000A2   0xBD00             POP      {PC}             ;; return
    246          
    247          /*
    248          void sensor_NVIC_Configure() {
    249            NVIC_InitTypeDef NVIC_InitStructure;
    250            
    251            NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    252            
    253            // NVIC Line ADC1
    254            NVIC_EnableIRQ(ADC1_2_IRQn);
    255            NVIC_InitStructure.NVIC_IRQChannel = ADC1_2_IRQn;
    256            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    257            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    258            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    259            NVIC_Init(&NVIC_InitStructure);
    260          }
    261          */
    262          

   \                                 In section .text, align 2, keep-with-next
    263          void sensor_DMA_Configure() {
   \                     sensor_DMA_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
    264            DMA_InitTypeDef DMA_Instructure;
    265            NVIC_InitTypeDef NVIC_InitStructure;
    266            
    267            NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
   \   00000004   0xF44F 0x60A0      MOV      R0,#+1280
   \   00000008   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    268            NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel1_IRQn;
   \   0000000C   0x200B             MOVS     R0,#+11
   \   0000000E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    269            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0001      STRB     R0,[SP, #+1]
    270            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    271            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF88D 0x0003      STRB     R0,[SP, #+3]
    272            NVIC_Init(&NVIC_InitStructure);
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x.... 0x....      BL       NVIC_Init
    273            
    274            DMA_DeInit(DMA1_Channel1);
   \   0000002A   0x....             LDR.N    R0,??DataTable12_14  ;; 0x40020008
   \   0000002C   0x.... 0x....      BL       DMA_DeInit
    275            /* DMA Configuration */
    276            ////////////////////////////////////////////////////////
    277            
    278            DMA_Instructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC1->DR;
   \   00000030   0x....             LDR.N    R0,??DataTable12_15  ;; 0x4001244c
   \   00000032   0x9001             STR      R0,[SP, #+4]
    279            DMA_Instructure.DMA_MemoryBaseAddr = (uint32_t)ADC_Value;
   \   00000034   0x....             LDR.N    R0,??DataTable12_16
   \   00000036   0x9002             STR      R0,[SP, #+8]
    280            DMA_Instructure.DMA_DIR = DMA_DIR_PeripheralSRC; // Peripheral@@ @@@ @@@
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x9003             STR      R0,[SP, #+12]
    281            
    282            DMA_Instructure.DMA_BufferSize = 3;
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0x9004             STR      R0,[SP, #+16]
    283            
    284            DMA_Instructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x9005             STR      R0,[SP, #+20]
    285            DMA_Instructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
   \   00000044   0x2080             MOVS     R0,#+128
   \   00000046   0x9006             STR      R0,[SP, #+24]
    286            DMA_Instructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
   \   00000048   0xF44F 0x7000      MOV      R0,#+512
   \   0000004C   0x9007             STR      R0,[SP, #+28]
    287            DMA_Instructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
   \   0000004E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000052   0x9008             STR      R0,[SP, #+32]
    288            
    289            DMA_Instructure.DMA_Mode = DMA_Mode_Circular; // Circular Mode
   \   00000054   0x2020             MOVS     R0,#+32
   \   00000056   0x9009             STR      R0,[SP, #+36]
    290            DMA_Instructure.DMA_Priority = DMA_Priority_VeryHigh;
   \   00000058   0xF44F 0x5040      MOV      R0,#+12288
   \   0000005C   0x900A             STR      R0,[SP, #+40]
    291            DMA_Instructure.DMA_M2M = DMA_M2M_Disable;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x900B             STR      R0,[SP, #+44]
    292            
    293            /////////////////////////////////////////////////////////
    294            
    295            
    296            DMA_Init(DMA1_Channel1, &DMA_Instructure);
   \   00000062   0xA901             ADD      R1,SP,#+4
   \   00000064   0x....             LDR.N    R0,??DataTable12_14  ;; 0x40020008
   \   00000066   0x.... 0x....      BL       DMA_Init
    297            DMA_ITConfig(DMA1_Channel1, DMA1_IT_TC1, ENABLE);
   \   0000006A   0x2201             MOVS     R2,#+1
   \   0000006C   0x2102             MOVS     R1,#+2
   \   0000006E   0x....             LDR.N    R0,??DataTable12_14  ;; 0x40020008
   \   00000070   0x.... 0x....      BL       DMA_ITConfig
    298            DMA_Cmd(DMA1_Channel1, ENABLE);
   \   00000074   0x2101             MOVS     R1,#+1
   \   00000076   0x....             LDR.N    R0,??DataTable12_14  ;; 0x40020008
   \   00000078   0x.... 0x....      BL       DMA_Cmd
    299            
    300            ADC_DMACmd(ADC1, ENABLE);
   \   0000007C   0x2101             MOVS     R1,#+1
   \   0000007E   0x....             LDR.N    R0,??DataTable12_13  ;; 0x40012400
   \   00000080   0x.... 0x....      BL       ADC_DMACmd
    301          }
   \   00000084   0xB00D             ADD      SP,SP,#+52
   \   00000086   0xBD00             POP      {PC}             ;; return
    302          

   \                                 In section .text, align 2, keep-with-next
    303          void DMA1_Channel1_IRQHandler() {
   \                     DMA1_Channel1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    304            if (DMA_GetITStatus(DMA1_IT_TC1) != RESET) {
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x.... 0x....      BL       DMA_GetITStatus
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD045             BEQ.N    ??DMA1_Channel1_IRQHandler_0
    305              if (ADC_Value[0] < 500 || ADC_Value[1] < 500 || ADC_Value[2] < 1500) {
   \   0000000C   0x....             LDR.N    R0,??DataTable12_16
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF5B0 0x7FFA      CMP      R0,#+500
   \   00000014   0xD30A             BCC.N    ??DMA1_Channel1_IRQHandler_1
   \   00000016   0x....             LDR.N    R0,??DataTable12_16
   \   00000018   0x6840             LDR      R0,[R0, #+4]
   \   0000001A   0xF5B0 0x7FFA      CMP      R0,#+500
   \   0000001E   0xD305             BCC.N    ??DMA1_Channel1_IRQHandler_1
   \   00000020   0x....             LDR.N    R0,??DataTable12_16
   \   00000022   0x6880             LDR      R0,[R0, #+8]
   \   00000024   0xF240 0x51DC      MOVW     R1,#+1500
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD232             BCS.N    ??DMA1_Channel1_IRQHandler_2
    306                SERVO_Rotate(&pwm3, 0);
   \                     ??DMA1_Channel1_IRQHandler_1: (+1)
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x....             LDR.N    R0,??DataTable12_6
   \   00000030   0x.... 0x....      BL       SERVO_Rotate
    307                delay(500);
   \   00000034   0xF44F 0x70FA      MOV      R0,#+500
   \   00000038   0x.... 0x....      BL       delay
    308                SERVO_Rotate(&pwm3, 30);
   \   0000003C   0x211E             MOVS     R1,#+30
   \   0000003E   0x....             LDR.N    R0,??DataTable12_6
   \   00000040   0x.... 0x....      BL       SERVO_Rotate
    309                delay(500);
   \   00000044   0xF44F 0x70FA      MOV      R0,#+500
   \   00000048   0x.... 0x....      BL       delay
    310                SERVO_Rotate(&pwm3, 0);
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x....             LDR.N    R0,??DataTable12_6
   \   00000050   0x.... 0x....      BL       SERVO_Rotate
    311                gameStatus.score++;
   \   00000054   0x....             LDR.N    R0,??DataTable12_8
   \   00000056   0x6840             LDR      R0,[R0, #+4]
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \   0000005A   0x....             LDR.N    R1,??DataTable12_8
   \   0000005C   0x6048             STR      R0,[R1, #+4]
    312                
    313                printf("game score : %d\n", gameStatus.score);
   \   0000005E   0x....             LDR.N    R0,??DataTable12_8
   \   00000060   0x6841             LDR      R1,[R0, #+4]
   \   00000062   0x....             LDR.N    R0,??DataTable12_17
   \   00000064   0x.... 0x....      BL       printf
    314                getDecStr(scoreResult, gameStatus.score);
   \   00000068   0x....             LDR.N    R0,??DataTable12_8
   \   0000006A   0x6840             LDR      R0,[R0, #+4]
   \   0000006C   0x0001             MOVS     R1,R0
   \   0000006E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000070   0x....             LDR.N    R0,??DataTable12_18
   \   00000072   0x.... 0x....      BL       getDecStr
    315                USART_SendData(USART2, *scoreResult);
   \   00000076   0x....             LDR.N    R0,??DataTable12_18
   \   00000078   0x8801             LDRH     R1,[R0, #+0]
   \   0000007A   0x....             LDR.N    R0,??DataTable12_9  ;; 0x40004400
   \   0000007C   0x.... 0x....      BL       USART_SendData
    316                
    317                printf("adc1: %d, adc2: %d, adc3: %d\n", ADC_Value[0], ADC_Value[1], ADC_Value[2]);
   \   00000080   0x....             LDR.N    R0,??DataTable12_16
   \   00000082   0x6883             LDR      R3,[R0, #+8]
   \   00000084   0x....             LDR.N    R0,??DataTable12_16
   \   00000086   0x6842             LDR      R2,[R0, #+4]
   \   00000088   0x....             LDR.N    R0,??DataTable12_16
   \   0000008A   0x6801             LDR      R1,[R0, #+0]
   \   0000008C   0x....             LDR.N    R0,??DataTable12_19
   \   0000008E   0x.... 0x....      BL       printf
    318              }
    319              DMA_ClearITPendingBit(DMA1_IT_TC1);
   \                     ??DMA1_Channel1_IRQHandler_2: (+1)
   \   00000092   0x2002             MOVS     R0,#+2
   \   00000094   0x.... 0x....      BL       DMA_ClearITPendingBit
    320            }
    321          }
   \                     ??DMA1_Channel1_IRQHandler_0: (+1)
   \   00000098   0xBD01             POP      {R0,PC}          ;; return
    322          
    323          /*
    324          void ADC1_2_IRQHandler() {
    325            if (ADC_GetITStatus(ADC1, ADC_IT_EOC) != RESET) {
    326              uint32_t adc_val = ADC_GetConversionValue(ADC1);
    327              if (adc_val < 500) {
    328                printf("Interrupt invoked2, ADC: %d\n", adc_val);
    329                
    330              }
    331              
    332              ADC_ClearITPendingBit(ADC1, ADC_IT_EOC);
    333            }
    334          }
    335          */
    336          
    337           /* ======================================================== */
    338          
    339          
    340              

   \                                 In section .text, align 2, keep-with-next
    341          void GPIO_Configure(void){
   \                     GPIO_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    342              GPIO_InitTypeDef GPIO_InitStructure;    
    343              // ???
    344              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
   \   00000002   0xF44F 0x6000      MOV      R0,#+2048
   \   00000006   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    345              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;// INPUT PULL-DOWN
   \   0000000A   0x2028             MOVS     R0,#+40
   \   0000000C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    346              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x....             LDR.N    R0,??DataTable12_20  ;; 0x40011400
   \   00000014   0x.... 0x....      BL       GPIO_Init
    347          }
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
    348          

   \                                 In section .text, align 2, keep-with-next
    349          int main(){
   \                     main: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    350              printf("Init\n");
   \   00000002   0x....             LDR.N    R0,??DataTable12_21
   \   00000004   0x.... 0x....      BL       printf
    351              SystemInit();
   \   00000008   0x.... 0x....      BL       SystemInit
    352              pwm_setting();
   \   0000000C   0x.... 0x....      BL       pwm_setting
    353              BT_init(&BT);
   \   00000010   0x....             LDR.N    R0,??DataTable12_22
   \   00000012   0x.... 0x....      BL       BT_init
    354              light_Init();
   \   00000016   0x.... 0x....      BL       light_Init
    355              GAME_init();
   \   0000001A   0x.... 0x....      BL       GAME_init
    356              sensor_RCC_Configure();
   \   0000001E   0x.... 0x....      BL       sensor_RCC_Configure
    357              sensor_GPIO_Configure();
   \   00000022   0x.... 0x....      BL       sensor_GPIO_Configure
    358              sensor_ADC_Configure();
   \   00000026   0x.... 0x....      BL       sensor_ADC_Configure
    359              //sensor_NVIC_Configure();
    360              sensor_DMA_Configure();
   \   0000002A   0x.... 0x....      BL       sensor_DMA_Configure
    361              
    362              while(1) {
    363                  /*if (score > 150) {
    364                      GPIO_SetBits(GPIOE, motor_num);
    365                  }*/
    366                  
    367                  //printf("adc1: %d, adc2: %d\n", ADC_Value[0], ADC_Value[1]);
    368                  delay(50000);
   \                     ??main_0: (+1)
   \   0000002E   0xF24C 0x3050      MOVW     R0,#+50000
   \   00000032   0x.... 0x....      BL       delay
   \   00000036   0xE7FA             B.N      ??main_0
    369                  /*SERVO_Rotate(&pwm, 80);
    370                  SERVO_Rotate(&pwm2, 80);
    371                  delay(800);
    372                  SERVO_Rotate(&pwm, 0);
    373                  SERVO_Rotate(&pwm2, 0);
    374                  delay(800);*/
    375              }
    376              
    377          
    378              return 0;
                     ^
Warning[Pe111]: statement is unreachable

        printf("adc1: %d, adc2: %d, adc3: %d\n", ADC_Value[0], ADC_Value[1], ADC_Value[2]);
        ^
"C:\Users\pnu6\Downloads\embedded_system_design-lab\PROJECT\termp_o\user\main.c",317  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement
    379          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x61 0x0A          DC8      0x61, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x62 0x0A          DC8      0x62, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x63 0x0A          DC8      0x63, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x64 0x0A          DC8      0x64, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x31 0x0A          DC8      0x31, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x32 0x0A          DC8      0x32, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x........         DC32     pwm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x........         DC32     pwm2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x........         DC32     pwm3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x........         DC32     pwm4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x........         DC32     gameStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \   00000000   0x40012400         DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \   00000000   0x40020008         DC32     0x40020008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \   00000000   0x4001244C         DC32     0x4001244c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \   00000000   0x........         DC32     ADC_Value

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_17:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_18:
   \   00000000   0x........         DC32     scoreResult

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_19:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_20:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_21:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_22:
   \   00000000   0x........         DC32     BT

   \                                 In section .rodata, align 4
   \   00000000   0x61 0x0A          DC8 "a\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0x62 0x0A          DC8 "b\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0x63 0x0A          DC8 "c\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0x64 0x0A          DC8 "d\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x73 0x74          DC8 "start button\012"
   \              0x61 0x72    
   \              0x74 0x20    
   \              0x62 0x75    
   \              0x74 0x74    
   \              0x6F 0x6E    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x31 0x0A          DC8 "1\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0x32 0x0A          DC8 "2\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x67 0x61          DC8 "game score : %d\012"
   \              0x6D 0x65    
   \              0x20 0x73    
   \              0x63 0x6F    
   \              0x72 0x65    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x64 0x0A    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x61 0x64          DC8 "adc1: %d, adc2: %d, adc3: %d\012"
   \              0x63 0x31    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x2C 0x20    
   \              0x61 0x64    
   \              0x63 0x32    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x2C 0x20    
   \              0x61 0x64    
   \              0x63 0x33    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x49 0x6E          DC8 "Init\012"
   \              0x69 0x74    
   \              0x0A 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DMA1_Channel1_IRQHandler
         8   -> DMA_ClearITPendingBit
         8   -> DMA_GetITStatus
         8   -> SERVO_Rotate
         8   -> USART_SendData
         8   -> delay
         8   -> getDecStr
         8   -> printf
       8   GAME_end
         8   -> USART_SendData
       0   GAME_init
       8   GAME_start
         8   -> SERVO_Rotate
         8   -> delay
       8   GPIO_Configure
         8   -> GPIO_Init
       8   USART1_IRQHandler
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
         8   -> USART_SendData
       8   USART2_IRQHandler
         8   -> GAME_start
         8   -> SERVO_Rotate
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
         8   -> USART_SendData
         8   -> printf
       0   delay
      16   getDecStr
       8   main
         8   -> BT_init
         8   -> GAME_init
         8   -> SystemInit
         8   -> delay
         8   -> light_Init
         8   -> printf
         8   -> pwm_setting
         8   -> sensor_ADC_Configure
         8   -> sensor_DMA_Configure
         8   -> sensor_GPIO_Configure
         8   -> sensor_RCC_Configure
       8   pwm_setting
         8   -> SERVO_Configure
         8   -> SERVO_Rotate
      24   sensor_ADC_Configure
        24   -> ADC_Cmd
        24   -> ADC_DMACmd
        24   -> ADC_GetCalibrationStatus
        24   -> ADC_GetResetCalibrationStatus
        24   -> ADC_ITConfig
        24   -> ADC_Init
        24   -> ADC_RegularChannelConfig
        24   -> ADC_ResetCalibration
        24   -> ADC_SoftwareStartConvCmd
        24   -> ADC_StartCalibration
        24   -> printf
      56   sensor_DMA_Configure
        56   -> ADC_DMACmd
        56   -> DMA_Cmd
        56   -> DMA_DeInit
        56   -> DMA_ITConfig
        56   -> DMA_Init
        56   -> NVIC_Init
        56   -> NVIC_PriorityGroupConfig
      16   sensor_GPIO_Configure
        16   -> GPIO_Init
       8   sensor_RCC_Configure
         8   -> RCC_AHBPeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_20
       4  ??DataTable12_21
       4  ??DataTable12_22
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       4  ??DataTable9
       4  ?_0
       4  ?_1
       4  ?_2
       4  ?_3
      16  ?_4
       4  ?_5
       4  ?_6
      20  ?_7
      32  ?_8
       8  ?_9
      12  ADC_Value
       2  BT
     154  DMA1_Channel1_IRQHandler
      32  GAME_end
      10  GAME_init
      58  GAME_start
      26  GPIO_Configure
      52  USART1_IRQHandler
     160  USART2_IRQHandler
      12  delay
       8  gameStatus
     102  getDecStr
       8  light_num
      56  main
       2  motor_num
      28  pwm
      28  pwm2
      28  pwm3
      28  pwm4
     300  pwm_setting
      16  scoreResult
     164  sensor_ADC_Configure
     136  sensor_DMA_Configure
      44  sensor_GPIO_Configure
      38  sensor_RCC_Configure

 
   150 bytes in section .bss
    10 bytes in section .data
   100 bytes in section .rodata
 1 452 bytes in section .text
 
 1 452 bytes of CODE  memory
   100 bytes of CONST memory
   160 bytes of DATA  memory

Errors: none
Warnings: 2
