###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       18/Dec/2022  21:51:07
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\pnu4\Downloads\embedded_system_design-lab\PROJECT\termp_o\user\main.c
#    Command line =  
#        -f C:\Users\pnu4\AppData\Local\Temp\EW8000.tmp
#        (C:\Users\pnu4\Downloads\embedded_system_design-lab\PROJECT\termp_o\user\main.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        C:\Users\pnu4\Downloads\embedded_system_design-lab\PROJECT\termp_o\Debug\List
#        -o
#        C:\Users\pnu4\Downloads\embedded_system_design-lab\PROJECT\termp_o\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\pnu4\Downloads\embedded_system_design-lab\PROJECT\termp_o\libraries\CMSIS\DeviceSupport\
#        -I
#        C:\Users\pnu4\Downloads\embedded_system_design-lab\PROJECT\termp_o\libraries\CMSIS\DeviceSupport\Startup\
#        -I
#        C:\Users\pnu4\Downloads\embedded_system_design-lab\PROJECT\termp_o\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\Users\pnu4\Downloads\embedded_system_design-lab\PROJECT\termp_o\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I
#        C:\Users\pnu4\Downloads\embedded_system_design-lab\PROJECT\termp_o\user\
#        -I
#        C:\Users\pnu4\Downloads\embedded_system_design-lab\PROJECT\termp_o\user\inc\
#        -Ol -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu4\Downloads\embedded_system_design-lab\PROJECT\termp_o\Debug\List\main.lst
#    Object file  =  
#        C:\Users\pnu4\Downloads\embedded_system_design-lab\PROJECT\termp_o\Debug\Obj\main.o
#
###############################################################################

C:\Users\pnu4\Downloads\embedded_system_design-lab\PROJECT\termp_o\user\main.c
      1          #include "common.h"
      2          #include "servo.h"
      3          #include "game.h"
      4          #include "bluetooth.h"
      5          #include "light.h"
      6          #include "motor.h"
      7          
      8          

   \                                 In section .text, align 2, keep-with-next
      9          void delay(int d){
     10            for (int i = 0; i <= d; i++) {
   \                     delay: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE000             B.N      ??delay_0
   \                     ??delay_1: (+1)
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \                     ??delay_0: (+1)
   \   00000006   0x4288             CMP      R0,R1
   \   00000008   0xDAFC             BGE.N    ??delay_1
     11                ;
     12            }
     13          } 
   \   0000000A   0x4770             BX       LR               ;; return
     14          

   \                                 In section .data, align 4
     15          uint16_t light_num[4] = {
   \                     light_num:
   \   00000000   0x0100 0x0200      DC16 256, 512, 1024, 2048
   \              0x0400 0x0800
     16              GPIO_Pin_8,
     17              GPIO_Pin_9,
     18              GPIO_Pin_10,
     19              GPIO_Pin_11
     20          };

   \                                 In section .data, align 2
     21          uint16_t motor_num = GPIO_Pin_2;
   \                     motor_num:
   \   00000000   0x0004             DC16 4
     22          

   \                                 In section .bss, align 4
     23          volatile uint32_t ADC_Value[6];
   \                     ADC_Value:
   \   00000000                      DS8 24

   \                                 In section .bss, align 4
     24          GameStatus gameStatus;
   \                     gameStatus:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     25          uint16_t scoreResult[8];
   \                     scoreResult:
   \   00000000                      DS8 16
     26          
     27          
     28          

   \                                 In section .text, align 2, keep-with-next
     29          void getDecStr(uint16_t* str, uint16_t val){
   \                     getDecStr: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x0002             MOVS     R2,R0
     30            uint16_t i;
     31            uint16_t len = 0;
   \   00000004   0x2300             MOVS     R3,#+0
     32            
     33            uint16_t valCopy = val;
   \   00000006   0x000C             MOVS     R4,R1
   \   00000008   0xE004             B.N      ??getDecStr_0
     34            
     35            while (valCopy > 0) {
     36              len++;
   \                     ??getDecStr_1: (+1)
   \   0000000A   0x1C5B             ADDS     R3,R3,#+1
     37              valCopy /= 10;
   \   0000000C   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000000E   0x200A             MOVS     R0,#+10
   \   00000010   0xFB94 0xF4F0      SDIV     R4,R4,R0
     38            }
   \                     ??getDecStr_0: (+1)
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD1F6             BNE.N    ??getDecStr_1
     39            
     40            for(i=1; i<=len; i++){
   \   0000001C   0x2401             MOVS     R4,#+1
   \   0000001E   0xE014             B.N      ??getDecStr_2
     41              str[len-i] = (uint8_t) ((val % 10UL) + '0');
   \                     ??getDecStr_3: (+1)
   \   00000020   0x000D             MOVS     R5,R1
   \   00000022   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000024   0x260A             MOVS     R6,#+10
   \   00000026   0x001F             MOVS     R7,R3
   \   00000028   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000002A   0x0020             MOVS     R0,R4
   \   0000002C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002E   0x1A3F             SUBS     R7,R7,R0
   \   00000030   0xFBB5 0xF0F6      UDIV     R0,R5,R6
   \   00000034   0xFB06 0x5510      MLS      R5,R6,R0,R5
   \   00000038   0x3530             ADDS     R5,R5,#+48
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0xF822 0x5017      STRH     R5,[R2, R7, LSL #+1]
     42              val/=10;
   \   00000040   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000042   0x200A             MOVS     R0,#+10
   \   00000044   0xFB91 0xF1F0      SDIV     R1,R1,R0
     43            }
   \   00000048   0x1C64             ADDS     R4,R4,#+1
   \                     ??getDecStr_2: (+1)
   \   0000004A   0x0018             MOVS     R0,R3
   \   0000004C   0x0025             MOVS     R5,R4
   \   0000004E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000050   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000052   0x42A8             CMP      R0,R5
   \   00000054   0xD2E4             BCS.N    ??getDecStr_3
     44          
     45            str[i-1] = '\0';
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   0000005A   0xEB02 0x0144      ADD      R1,R2,R4, LSL #+1
   \   0000005E   0xF821 0x0C02      STRH     R0,[R1, #-2]
     46          }
   \   00000062   0xBCF0             POP      {R4-R7}
   \   00000064   0x4770             BX       LR               ;; return
     47          
     48          /* ========================= SERVO ========================= */
     49          
     50          

   \                                 In section .bss, align 4
     51          PWM pwm, pwm2, pwm3, pwm4, pwm5;
   \                     pwm:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
   \                     pwm2:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
   \                     pwm3:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
   \                     pwm4:
   \   00000000                      DS8 28

   \                                 In section .bss, align 4
   \                     pwm5:
   \   00000000                      DS8 28
     52          

   \                                 In section .text, align 2, keep-with-next
     53          static void pwm_setting(){
   \                     pwm_setting: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     54              pwm.OCMode     = TIM_OCMode_PWM1;
   \   00000002   0x2060             MOVS     R0,#+96
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000008   0x8088             STRH     R0,[R1, #+4]
     55              pwm.rcc_timer    = RCC_APB1Periph_TIM4;
   \   0000000A   0x2004             MOVS     R0,#+4
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000010   0x6088             STR      R0,[R1, #+8]
     56              pwm.timer           = TIM4;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40000800
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000001A   0x60C8             STR      R0,[R1, #+12]
     57              pwm.rcc_gpio     = RCC_APB2Periph_GPIOB;
   \   0000001C   0x2008             MOVS     R0,#+8
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000022   0x6108             STR      R0,[R1, #+16]
     58              pwm.gpio_port    = GPIOB;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40010c00
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000002C   0x6148             STR      R0,[R1, #+20]
     59              pwm.gpio_pin     = GPIO_Pin_8;
   \   0000002E   0xF44F 0x7080      MOV      R0,#+256
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000036   0x8308             STRH     R0,[R1, #+24]
     60              pwm.channel      = 3;
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000003E   0x6008             STR      R0,[R1, #+0]
     61              SERVO_Configure(&pwm);
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   00000044   0x.... 0x....      BL       SERVO_Configure
     62              SERVO_Rotate(&pwm, 90);
   \   00000048   0x215A             MOVS     R1,#+90
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   0000004E   0x.... 0x....      BL       SERVO_Rotate
     63              
     64              pwm2.OCMode    = TIM_OCMode_PWM1;
   \   00000052   0x2060             MOVS     R0,#+96
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   00000058   0x8088             STRH     R0,[R1, #+4]
     65              pwm2.rcc_timer   = RCC_APB1Periph_TIM4;
   \   0000005A   0x2004             MOVS     R0,#+4
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   00000060   0x6088             STR      R0,[R1, #+8]
     66              pwm2.timer          = TIM4;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40000800
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   0000006A   0x60C8             STR      R0,[R1, #+12]
     67              pwm2.rcc_gpio    = RCC_APB2Periph_GPIOB;
   \   0000006C   0x2008             MOVS     R0,#+8
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   00000072   0x6108             STR      R0,[R1, #+16]
     68              pwm2.gpio_port   = GPIOB;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40010c00
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   0000007C   0x6148             STR      R0,[R1, #+20]
     69              pwm2.gpio_pin    = GPIO_Pin_9;
   \   0000007E   0xF44F 0x7000      MOV      R0,#+512
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   00000086   0x8308             STRH     R0,[R1, #+24]
     70              pwm2.channel     = 4;
   \   00000088   0x2004             MOVS     R0,#+4
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   0000008E   0x6008             STR      R0,[R1, #+0]
     71              SERVO_Configure(&pwm2);
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable12_5
   \   00000094   0x.... 0x....      BL       SERVO_Configure
     72              SERVO_Rotate(&pwm2, 150);
   \   00000098   0x2196             MOVS     R1,#+150
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable12_5
   \   0000009E   0x.... 0x....      BL       SERVO_Rotate
     73              
     74              pwm3.OCMode    = TIM_OCMode_PWM1;
   \   000000A2   0x2060             MOVS     R0,#+96
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000A8   0x8088             STRH     R0,[R1, #+4]
     75              pwm3.rcc_timer   = RCC_APB1Periph_TIM4;
   \   000000AA   0x2004             MOVS     R0,#+4
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000B0   0x6088             STR      R0,[R1, #+8]
     76              pwm3.timer          = TIM4;
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40000800
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000BA   0x60C8             STR      R0,[R1, #+12]
     77              pwm3.rcc_gpio    = RCC_APB2Periph_GPIOB;
   \   000000BC   0x2008             MOVS     R0,#+8
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000C2   0x6108             STR      R0,[R1, #+16]
     78              pwm3.gpio_port   = GPIOB;
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40010c00
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000CC   0x6148             STR      R0,[R1, #+20]
     79              pwm3.gpio_pin    = GPIO_Pin_6;
   \   000000CE   0x2040             MOVS     R0,#+64
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000D4   0x8308             STRH     R0,[R1, #+24]
     80              pwm3.channel     = 1;
   \   000000D6   0x2001             MOVS     R0,#+1
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000DC   0x6008             STR      R0,[R1, #+0]
     81              SERVO_Configure(&pwm3);
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable12_6
   \   000000E2   0x.... 0x....      BL       SERVO_Configure
     82              
     83              // start servo
     84              pwm4.OCMode    = TIM_OCMode_PWM1;
   \   000000E6   0x2060             MOVS     R0,#+96
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable12_7
   \   000000EC   0x8088             STRH     R0,[R1, #+4]
     85              pwm4.rcc_timer   = RCC_APB1Periph_TIM4;
   \   000000EE   0x2004             MOVS     R0,#+4
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable12_7
   \   000000F4   0x6088             STR      R0,[R1, #+8]
     86              pwm4.timer          = TIM4;
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable12_3  ;; 0x40000800
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable12_7
   \   000000FE   0x60C8             STR      R0,[R1, #+12]
     87              pwm4.rcc_gpio    = RCC_APB2Periph_GPIOB;
   \   00000100   0x2008             MOVS     R0,#+8
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable12_7
   \   00000106   0x6108             STR      R0,[R1, #+16]
     88              pwm4.gpio_port   = GPIOB;
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable12_4  ;; 0x40010c00
   \   0000010C   0x.... 0x....      LDR.W    R1,??DataTable12_7
   \   00000110   0x6148             STR      R0,[R1, #+20]
     89              pwm4.gpio_pin    = GPIO_Pin_7;
   \   00000112   0x2080             MOVS     R0,#+128
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable12_7
   \   00000118   0x8308             STRH     R0,[R1, #+24]
     90              pwm4.channel     = 2;
   \   0000011A   0x2002             MOVS     R0,#+2
   \   0000011C   0x.... 0x....      LDR.W    R1,??DataTable12_7
   \   00000120   0x6008             STR      R0,[R1, #+0]
     91              SERVO_Configure(&pwm4);
   \   00000122   0x.... 0x....      LDR.W    R0,??DataTable12_7
   \   00000126   0x.... 0x....      BL       SERVO_Configure
     92              
     93              pwm5.OCMode    = TIM_OCMode_PWM1;
   \   0000012A   0x2060             MOVS     R0,#+96
   \   0000012C   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   00000130   0x8088             STRH     R0,[R1, #+4]
     94              pwm5.rcc_timer   = RCC_APB1Periph_TIM2;
   \   00000132   0x2001             MOVS     R0,#+1
   \   00000134   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   00000138   0x6088             STR      R0,[R1, #+8]
     95              pwm5.timer          = TIM2;
   \   0000013A   0xF05F 0x4080      MOVS     R0,#+1073741824
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   00000142   0x60C8             STR      R0,[R1, #+12]
     96              pwm5.rcc_gpio    = RCC_APB2Periph_GPIOA;
   \   00000144   0x2004             MOVS     R0,#+4
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   0000014A   0x6108             STR      R0,[R1, #+16]
     97              pwm5.gpio_port   = GPIOA;
   \   0000014C   0x.... 0x....      LDR.W    R0,??DataTable12_9  ;; 0x40010800
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   00000154   0x6148             STR      R0,[R1, #+20]
     98              pwm5.gpio_pin    = GPIO_Pin_3;
   \   00000156   0x2008             MOVS     R0,#+8
   \   00000158   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   0000015C   0x8308             STRH     R0,[R1, #+24]
     99              pwm5.channel     = 4;
   \   0000015E   0x2004             MOVS     R0,#+4
   \   00000160   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   00000164   0x6008             STR      R0,[R1, #+0]
    100              SERVO_Configure(&pwm5);
   \   00000166   0x.... 0x....      LDR.W    R0,??DataTable12_8
   \   0000016A   0x.... 0x....      BL       SERVO_Configure
    101          }
   \   0000016E   0xBD01             POP      {R0,PC}          ;; return
    102          
    103          
    104          
    105          /* ========================= GAME ========================= */
    106          

   \                                 In section .text, align 2, keep-with-next
    107          void GAME_init(){
    108              gameStatus.start = 0;
   \                     GAME_init: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable12_10
   \   00000006   0x6008             STR      R0,[R1, #+0]
    109              // led ???? ???
    110          }
   \   00000008   0x4770             BX       LR               ;; return
    111          

   \                                 In section .text, align 2, keep-with-next
    112          void GAME_start(){
   \                     GAME_start: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    113              if (gameStatus.start != 1){
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable12_10
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD015             BEQ.N    ??GAME_start_0
    114                  gameStatus.start = 1;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable12_10
   \   00000012   0x6008             STR      R0,[R1, #+0]
    115                  gameStatus.score = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable12_10
   \   0000001A   0x6048             STR      R0,[R1, #+4]
    116                  
    117                  SERVO_Rotate(&pwm4, 180);
   \   0000001C   0x21B4             MOVS     R1,#+180
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable12_7
   \   00000022   0x.... 0x....      BL       SERVO_Rotate
    118                  delay(1000);
   \   00000026   0xF44F 0x707A      MOV      R0,#+1000
   \   0000002A   0x.... 0x....      BL       delay
    119                  SERVO_Rotate(&pwm4, 0);
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable12_7
   \   00000034   0x.... 0x....      BL       SERVO_Rotate
    120                  
    121                  // led ???? ???
    122              }
    123          }
   \                     ??GAME_start_0: (+1)
   \   00000038   0xBD01             POP      {R0,PC}          ;; return
    124          

   \                                 In section .text, align 2, keep-with-next
    125          void GAME_end(){
   \                     GAME_end: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    126              if (gameStatus.start != 0){
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable12_10
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD008             BEQ.N    ??GAME_end_0
    127                  USART_SendData(USART2, 'e');
   \   0000000C   0x2165             MOVS     R1,#+101
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable12_11  ;; 0x40004400
   \   00000012   0x.... 0x....      BL       USART_SendData
    128                  gameStatus.start = 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable12_10
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    129                  
    130                  // led ???? ???
    131              }
    132          }
   \                     ??GAME_end_0: (+1)
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
    133          
    134          
    135          /* ========================== BT ==========================*/
    136          

   \                                 In section .bss, align 2
    137          BTConfig BT;
   \                     BT:
   \   00000000                      DS8 2
    138          
    139          // USART Interrupt Handler
    140          

   \                                 In section .text, align 2, keep-with-next
    141          void USART1_IRQHandler() {
   \                     USART1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    142              uint16_t word;
    143              if(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET){
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable12_12  ;; 0x40013800
   \   0000000A   0x.... 0x....      BL       USART_GetITStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD00F             BEQ.N    ??USART1_IRQHandler_0
    144              // the most recent received data by the USART1 peripheral
    145              word = USART_ReceiveData(USART1);
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable12_12  ;; 0x40013800
   \   00000016   0x.... 0x....      BL       USART_ReceiveData
   \   0000001A   0x0001             MOVS     R1,R0
    146              
    147              // ??->?????? ?????? (????)
    148              USART_SendData(USART2, word);
   \   0000001C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable12_11  ;; 0x40004400
   \   00000022   0x.... 0x....      BL       USART_SendData
    149          
    150              // clear 'Read data register not empty' flag
    151              USART_ClearITPendingBit(USART1,USART_IT_RXNE);
   \   00000026   0xF240 0x5125      MOVW     R1,#+1317
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable12_12  ;; 0x40013800
   \   0000002E   0x.... 0x....      BL       USART_ClearITPendingBit
    152              }
    153          }
   \                     ??USART1_IRQHandler_0: (+1)
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
    154          

   \                                 In section .text, align 2, keep-with-next
    155          void USART2_IRQHandler(){
   \                     USART2_IRQHandler: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    156              uint16_t word;
    157              if(USART_GetITStatus(USART2,USART_IT_RXNE)!=RESET){
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable12_11  ;; 0x40004400
   \   0000000A   0x.... 0x....      BL       USART_GetITStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD048             BEQ.N    ??USART2_IRQHandler_0
    158                
    159              word = USART_ReceiveData(USART2);
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable12_11  ;; 0x40004400
   \   00000016   0x.... 0x....      BL       USART_ReceiveData
   \   0000001A   0x0004             MOVS     R4,R0
    160              if (word == 'a') {
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000020   0x2861             CMP      R0,#+97
   \   00000022   0xD108             BNE.N    ??USART2_IRQHandler_1
    161                printf("a\n");
   \   00000024   0x....             ADR.N    R0,??DataTable9  ;; 0x61, 0x0A, 0x00, 0x00
   \   00000026   0x.... 0x....      BL       printf
    162                SERVO_Rotate(&pwm, 210);
   \   0000002A   0x21D2             MOVS     R1,#+210
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   00000030   0x.... 0x....      BL       SERVO_Rotate
   \   00000034   0xE02C             B.N      ??USART2_IRQHandler_2
    163              }
    164              else if (word == 'b') {
   \                     ??USART2_IRQHandler_1: (+1)
   \   00000036   0x0020             MOVS     R0,R4
   \   00000038   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003A   0x2862             CMP      R0,#+98
   \   0000003C   0xD107             BNE.N    ??USART2_IRQHandler_3
    165                printf("b\n");
   \   0000003E   0x....             ADR.N    R0,??DataTable9_1  ;; 0x62, 0x0A, 0x00, 0x00
   \   00000040   0x.... 0x....      BL       printf
    166                SERVO_Rotate(&pwm, 0);
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x....             LDR.N    R0,??DataTable12_2
   \   00000048   0x.... 0x....      BL       SERVO_Rotate
   \   0000004C   0xE020             B.N      ??USART2_IRQHandler_2
    167              }
    168              else if (word == 'c') {
   \                     ??USART2_IRQHandler_3: (+1)
   \   0000004E   0x0020             MOVS     R0,R4
   \   00000050   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000052   0x2863             CMP      R0,#+99
   \   00000054   0xD107             BNE.N    ??USART2_IRQHandler_4
    169                printf("c\n");
   \   00000056   0x....             ADR.N    R0,??DataTable9_2  ;; 0x63, 0x0A, 0x00, 0x00
   \   00000058   0x.... 0x....      BL       printf
    170                SERVO_Rotate(&pwm2, 0);
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x....             LDR.N    R0,??DataTable12_5
   \   00000060   0x.... 0x....      BL       SERVO_Rotate
   \   00000064   0xE014             B.N      ??USART2_IRQHandler_2
    171              }
    172              else if (word == 'd') {
   \                     ??USART2_IRQHandler_4: (+1)
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000006A   0x2864             CMP      R0,#+100
   \   0000006C   0xD107             BNE.N    ??USART2_IRQHandler_5
    173                printf("d\n");
   \   0000006E   0x....             ADR.N    R0,??DataTable9_3  ;; 0x64, 0x0A, 0x00, 0x00
   \   00000070   0x.... 0x....      BL       printf
    174                SERVO_Rotate(&pwm2, 210);
   \   00000074   0x21D2             MOVS     R1,#+210
   \   00000076   0x....             LDR.N    R0,??DataTable12_5
   \   00000078   0x.... 0x....      BL       SERVO_Rotate
   \   0000007C   0xE008             B.N      ??USART2_IRQHandler_2
    175              }
    176              /*else if (word == 's') {
    177                printf("game score : %d\n", gameStatus.score);
    178                USART_SendData(USART2, gameStatus.score);
    179              }*/
    180              else if (word == 'k') {
   \                     ??USART2_IRQHandler_5: (+1)
   \   0000007E   0x0020             MOVS     R0,R4
   \   00000080   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000082   0x286B             CMP      R0,#+107
   \   00000084   0xD104             BNE.N    ??USART2_IRQHandler_2
    181                printf("start button\n");
   \   00000086   0x....             LDR.N    R0,??DataTable12_13
   \   00000088   0x.... 0x....      BL       printf
    182                GAME_start();
   \   0000008C   0x.... 0x....      BL       GAME_start
    183              }
    184              
    185              USART_SendData(USART1, word);
   \                     ??USART2_IRQHandler_2: (+1)
   \   00000090   0x0021             MOVS     R1,R4
   \   00000092   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000094   0x....             LDR.N    R0,??DataTable12_12  ;; 0x40013800
   \   00000096   0x.... 0x....      BL       USART_SendData
    186              USART_ClearITPendingBit(USART2,USART_IT_RXNE);
   \   0000009A   0xF240 0x5125      MOVW     R1,#+1317
   \   0000009E   0x....             LDR.N    R0,??DataTable12_11  ;; 0x40004400
   \   000000A0   0x.... 0x....      BL       USART_ClearITPendingBit
    187              }
    188          }
   \                     ??USART2_IRQHandler_0: (+1)
   \   000000A4   0xBD10             POP      {R4,PC}          ;; return
    189          
    190          /* ========================= LED ========================= */
    191          
    192          
    193          /* ========================= SENSOR ========================= */
    194          

   \                                 In section .text, align 2, keep-with-next
    195          void sensor_RCC_Configure() {
   \                     sensor_RCC_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    196            RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0xF44F 0x7000      MOV      R0,#+512
   \   00000008   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    197            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \   0000000C   0x2101             MOVS     R1,#+1
   \   0000000E   0x2008             MOVS     R0,#+8
   \   00000010   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    198            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x2010             MOVS     R0,#+16
   \   00000018   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    199            // RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
    200            // DMA port clock enable
    201            RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x.... 0x....      BL       RCC_AHBPeriphClockCmd
    202          }
   \   00000024   0xBD01             POP      {R0,PC}          ;; return
    203          

   \                                 In section .text, align 2, keep-with-next
    204          void sensor_GPIO_Configure() {
   \                     sensor_GPIO_Configure: (+1)
   \   00000000   0xB5E0             PUSH     {R5-R7,LR}
    205            GPIO_InitTypeDef GPIO_InitStructure;
    206            GPIO_InitTypeDef GPIO_InitStructure_C;
    207            
    208            // ADC Port Configure
    209            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
   \   00000002   0x2003             MOVS     R0,#+3
   \   00000004   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    210            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF88D 0x0007      STRB     R0,[SP, #+7]
    211            GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   0000000E   0xA901             ADD      R1,SP,#+4
   \   00000010   0x....             LDR.N    R0,??DataTable12_4  ;; 0x40010c00
   \   00000012   0x.... 0x....      BL       GPIO_Init
    212            
    213            GPIO_InitStructure_C.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3;
   \   00000016   0x200F             MOVS     R0,#+15
   \   00000018   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    214            GPIO_InitStructure_C.GPIO_Mode = GPIO_Mode_AIN;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    215            GPIO_Init(GPIOC, &GPIO_InitStructure_C);
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x....             LDR.N    R0,??DataTable12_14  ;; 0x40011000
   \   00000026   0x.... 0x....      BL       GPIO_Init
    216          }
   \   0000002A   0xBD07             POP      {R0-R2,PC}       ;; return
    217          

   \                                 In section .text, align 2, keep-with-next
    218          void sensor_ADC_Configure() {
   \                     sensor_ADC_Configure: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    219            ADC_InitTypeDef ADC_InitStructure;
    220            
    221            // ADC Configure
    222            ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9000             STR      R0,[SP, #+0]
    223            ADC_InitStructure.ADC_ScanConvMode = ENABLE;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0xF88D 0x0004      STRB     R0,[SP, #+4]
    224            ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xF88D 0x0005      STRB     R0,[SP, #+5]
    225            ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
   \   00000014   0xF45F 0x2060      MOVS     R0,#+917504
   \   00000018   0x9002             STR      R0,[SP, #+8]
    226            ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x9003             STR      R0,[SP, #+12]
    227            ADC_InitStructure.ADC_NbrOfChannel = 6;
   \   0000001E   0x2006             MOVS     R0,#+6
   \   00000020   0xF88D 0x0010      STRB     R0,[SP, #+16]
    228            
    229            ADC_Init(ADC1, &ADC_InitStructure);
   \   00000024   0x4669             MOV      R1,SP
   \   00000026   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40012400
   \   00000028   0x.... 0x....      BL       ADC_Init
    230            
    231            ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 1, ADC_SampleTime_239Cycles5); // PB0
   \   0000002C   0x2307             MOVS     R3,#+7
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0x2108             MOVS     R1,#+8
   \   00000032   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40012400
   \   00000034   0x.... 0x....      BL       ADC_RegularChannelConfig
    232            ADC_RegularChannelConfig(ADC1, ADC_Channel_9, 2, ADC_SampleTime_239Cycles5); // PB1
   \   00000038   0x2307             MOVS     R3,#+7
   \   0000003A   0x2202             MOVS     R2,#+2
   \   0000003C   0x2109             MOVS     R1,#+9
   \   0000003E   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40012400
   \   00000040   0x.... 0x....      BL       ADC_RegularChannelConfig
    233            ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 3, ADC_SampleTime_239Cycles5); // PC0
   \   00000044   0x2307             MOVS     R3,#+7
   \   00000046   0x2203             MOVS     R2,#+3
   \   00000048   0x210A             MOVS     R1,#+10
   \   0000004A   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40012400
   \   0000004C   0x.... 0x....      BL       ADC_RegularChannelConfig
    234            ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 4, ADC_SampleTime_239Cycles5); // PC1
   \   00000050   0x2307             MOVS     R3,#+7
   \   00000052   0x2204             MOVS     R2,#+4
   \   00000054   0x210B             MOVS     R1,#+11
   \   00000056   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40012400
   \   00000058   0x.... 0x....      BL       ADC_RegularChannelConfig
    235            ADC_RegularChannelConfig(ADC1, ADC_Channel_12, 5, ADC_SampleTime_239Cycles5); // PC2
   \   0000005C   0x2307             MOVS     R3,#+7
   \   0000005E   0x2205             MOVS     R2,#+5
   \   00000060   0x210C             MOVS     R1,#+12
   \   00000062   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40012400
   \   00000064   0x.... 0x....      BL       ADC_RegularChannelConfig
    236            ADC_RegularChannelConfig(ADC1, ADC_Channel_13, 6, ADC_SampleTime_239Cycles5); // PC3
   \   00000068   0x2307             MOVS     R3,#+7
   \   0000006A   0x2206             MOVS     R2,#+6
   \   0000006C   0x210D             MOVS     R1,#+13
   \   0000006E   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40012400
   \   00000070   0x.... 0x....      BL       ADC_RegularChannelConfig
    237            
    238            // Enable interrupt
    239            ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);
   \   00000074   0x2201             MOVS     R2,#+1
   \   00000076   0xF44F 0x7108      MOV      R1,#+544
   \   0000007A   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40012400
   \   0000007C   0x.... 0x....      BL       ADC_ITConfig
    240            ADC_DMACmd(ADC1, ENABLE);
   \   00000080   0x2101             MOVS     R1,#+1
   \   00000082   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40012400
   \   00000084   0x.... 0x....      BL       ADC_DMACmd
    241            
    242            // Enable ADC1
    243            ADC_Cmd(ADC1, ENABLE);
   \   00000088   0x2101             MOVS     R1,#+1
   \   0000008A   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40012400
   \   0000008C   0x.... 0x....      BL       ADC_Cmd
    244            ADC_ResetCalibration(ADC1);
   \   00000090   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40012400
   \   00000092   0x.... 0x....      BL       ADC_ResetCalibration
    245            
    246            printf("1\n");
   \   00000096   0x....             ADR.N    R0,??DataTable12  ;; 0x31, 0x0A, 0x00, 0x00
   \   00000098   0x.... 0x....      BL       printf
    247            
    248            while(ADC_GetResetCalibrationStatus(ADC1));
   \                     ??sensor_ADC_Configure_0: (+1)
   \   0000009C   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40012400
   \   0000009E   0x.... 0x....      BL       ADC_GetResetCalibrationStatus
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD1FA             BNE.N    ??sensor_ADC_Configure_0
    249            
    250            printf("2\n");
   \   000000A6   0x....             ADR.N    R0,??DataTable12_1  ;; 0x32, 0x0A, 0x00, 0x00
   \   000000A8   0x.... 0x....      BL       printf
    251            
    252            ADC_StartCalibration(ADC1);
   \   000000AC   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40012400
   \   000000AE   0x.... 0x....      BL       ADC_StartCalibration
    253            
    254            while(ADC_GetCalibrationStatus(ADC1));
   \                     ??sensor_ADC_Configure_1: (+1)
   \   000000B2   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40012400
   \   000000B4   0x.... 0x....      BL       ADC_GetCalibrationStatus
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD1FA             BNE.N    ??sensor_ADC_Configure_1
    255            
    256            ADC_SoftwareStartConvCmd(ADC1, ENABLE);
   \   000000BC   0x2101             MOVS     R1,#+1
   \   000000BE   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40012400
   \   000000C0   0x.... 0x....      BL       ADC_SoftwareStartConvCmd
    257          }
   \   000000C4   0xB005             ADD      SP,SP,#+20
   \   000000C6   0xBD00             POP      {PC}             ;; return
    258          
    259          /*
    260          void sensor_NVIC_Configure() {
    261            NVIC_InitTypeDef NVIC_InitStructure;
    262            
    263            NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    264            
    265            // NVIC Line ADC1
    266            NVIC_EnableIRQ(ADC1_2_IRQn);
    267            NVIC_InitStructure.NVIC_IRQChannel = ADC1_2_IRQn;
    268            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    269            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    270            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    271            NVIC_Init(&NVIC_InitStructure);
    272          }
    273          */
    274          

   \                                 In section .text, align 2, keep-with-next
    275          void sensor_DMA_Configure() {
   \                     sensor_DMA_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0xB08C             SUB      SP,SP,#+48
    276            DMA_InitTypeDef DMA_Instructure;
    277            NVIC_InitTypeDef NVIC_InitStructure;
    278            
    279            NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
   \   00000004   0xF44F 0x60A0      MOV      R0,#+1280
   \   00000008   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    280            NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel1_IRQn;
   \   0000000C   0x200B             MOVS     R0,#+11
   \   0000000E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    281            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF88D 0x0001      STRB     R0,[SP, #+1]
    282            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    283            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xF88D 0x0003      STRB     R0,[SP, #+3]
    284            NVIC_Init(&NVIC_InitStructure);
   \   00000024   0x4668             MOV      R0,SP
   \   00000026   0x.... 0x....      BL       NVIC_Init
    285            
    286            DMA_DeInit(DMA1_Channel1);
   \   0000002A   0x....             LDR.N    R0,??DataTable12_16  ;; 0x40020008
   \   0000002C   0x.... 0x....      BL       DMA_DeInit
    287            /* DMA Configuration */
    288            ////////////////////////////////////////////////////////
    289            
    290            DMA_Instructure.DMA_PeripheralBaseAddr = (uint32_t)&ADC1->DR;
   \   00000030   0x....             LDR.N    R0,??DataTable12_17  ;; 0x4001244c
   \   00000032   0x9001             STR      R0,[SP, #+4]
    291            DMA_Instructure.DMA_MemoryBaseAddr = (uint32_t)ADC_Value;
   \   00000034   0x....             LDR.N    R0,??DataTable12_18
   \   00000036   0x9002             STR      R0,[SP, #+8]
    292            DMA_Instructure.DMA_DIR = DMA_DIR_PeripheralSRC; // Peripheral@@ @@@ @@@
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x9003             STR      R0,[SP, #+12]
    293            
    294            DMA_Instructure.DMA_BufferSize = 6;
   \   0000003C   0x2006             MOVS     R0,#+6
   \   0000003E   0x9004             STR      R0,[SP, #+16]
    295            
    296            DMA_Instructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x9005             STR      R0,[SP, #+20]
    297            DMA_Instructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
   \   00000044   0x2080             MOVS     R0,#+128
   \   00000046   0x9006             STR      R0,[SP, #+24]
    298            DMA_Instructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
   \   00000048   0xF44F 0x7000      MOV      R0,#+512
   \   0000004C   0x9007             STR      R0,[SP, #+28]
    299            DMA_Instructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
   \   0000004E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000052   0x9008             STR      R0,[SP, #+32]
    300            
    301            DMA_Instructure.DMA_Mode = DMA_Mode_Circular; // Circular Mode
   \   00000054   0x2020             MOVS     R0,#+32
   \   00000056   0x9009             STR      R0,[SP, #+36]
    302            DMA_Instructure.DMA_Priority = DMA_Priority_VeryHigh;
   \   00000058   0xF44F 0x5040      MOV      R0,#+12288
   \   0000005C   0x900A             STR      R0,[SP, #+40]
    303            DMA_Instructure.DMA_M2M = DMA_M2M_Disable;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x900B             STR      R0,[SP, #+44]
    304            
    305            /////////////////////////////////////////////////////////
    306            
    307            
    308            DMA_Init(DMA1_Channel1, &DMA_Instructure);
   \   00000062   0xA901             ADD      R1,SP,#+4
   \   00000064   0x....             LDR.N    R0,??DataTable12_16  ;; 0x40020008
   \   00000066   0x.... 0x....      BL       DMA_Init
    309            DMA_ITConfig(DMA1_Channel1, DMA1_IT_TC1, ENABLE);
   \   0000006A   0x2201             MOVS     R2,#+1
   \   0000006C   0x2102             MOVS     R1,#+2
   \   0000006E   0x....             LDR.N    R0,??DataTable12_16  ;; 0x40020008
   \   00000070   0x.... 0x....      BL       DMA_ITConfig
    310            DMA_Cmd(DMA1_Channel1, ENABLE);
   \   00000074   0x2101             MOVS     R1,#+1
   \   00000076   0x....             LDR.N    R0,??DataTable12_16  ;; 0x40020008
   \   00000078   0x.... 0x....      BL       DMA_Cmd
    311            
    312            ADC_DMACmd(ADC1, ENABLE);
   \   0000007C   0x2101             MOVS     R1,#+1
   \   0000007E   0x....             LDR.N    R0,??DataTable12_15  ;; 0x40012400
   \   00000080   0x.... 0x....      BL       ADC_DMACmd
    313          }
   \   00000084   0xB00D             ADD      SP,SP,#+52
   \   00000086   0xBD00             POP      {PC}             ;; return
    314          

   \                                 In section .text, align 2, keep-with-next
    315          void DMA1_Channel1_IRQHandler() {
   \                     DMA1_Channel1_IRQHandler: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    316            if (DMA_GetITStatus(DMA1_IT_TC1) != RESET) {
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x.... 0x....      BL       DMA_GetITStatus
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD05C             BEQ.N    ??DMA1_Channel1_IRQHandler_0
    317              if (ADC_Value[0] < 500 || ADC_Value[1] < 500 || ADC_Value[2] < 500 
    318                  || ADC_Value[3] < 1500 || ADC_Value[4] < 500) {
   \   0000000C   0x....             LDR.N    R0,??DataTable12_18
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0xF5B0 0x7FFA      CMP      R0,#+500
   \   00000014   0xD314             BCC.N    ??DMA1_Channel1_IRQHandler_1
   \   00000016   0x....             LDR.N    R0,??DataTable12_18
   \   00000018   0x6840             LDR      R0,[R0, #+4]
   \   0000001A   0xF5B0 0x7FFA      CMP      R0,#+500
   \   0000001E   0xD30F             BCC.N    ??DMA1_Channel1_IRQHandler_1
   \   00000020   0x....             LDR.N    R0,??DataTable12_18
   \   00000022   0x6880             LDR      R0,[R0, #+8]
   \   00000024   0xF5B0 0x7FFA      CMP      R0,#+500
   \   00000028   0xD30A             BCC.N    ??DMA1_Channel1_IRQHandler_1
   \   0000002A   0x....             LDR.N    R0,??DataTable12_18
   \   0000002C   0x68C0             LDR      R0,[R0, #+12]
   \   0000002E   0xF240 0x51DC      MOVW     R1,#+1500
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD304             BCC.N    ??DMA1_Channel1_IRQHandler_1
   \   00000036   0x....             LDR.N    R0,??DataTable12_18
   \   00000038   0x6900             LDR      R0,[R0, #+16]
   \   0000003A   0xF5B0 0x7FFA      CMP      R0,#+500
   \   0000003E   0xD23F             BCS.N    ??DMA1_Channel1_IRQHandler_2
    319                
    320                printf("adc1: %d, adc2: %d, adc3: %d\nadc4: %d, adc5: %d, adc6: %d\n", ADC_Value[0], ADC_Value[1], ADC_Value[2], ADC_Value[3], ADC_Value[4], ADC_Value[5]);
   \                     ??DMA1_Channel1_IRQHandler_1: (+1)
   \   00000040   0x....             LDR.N    R0,??DataTable12_18
   \   00000042   0x6940             LDR      R0,[R0, #+20]
   \   00000044   0x....             LDR.N    R1,??DataTable12_18
   \   00000046   0x6909             LDR      R1,[R1, #+16]
   \   00000048   0x....             LDR.N    R2,??DataTable12_18
   \   0000004A   0x68D4             LDR      R4,[R2, #+12]
   \   0000004C   0x....             LDR.N    R2,??DataTable12_18
   \   0000004E   0x6893             LDR      R3,[R2, #+8]
   \   00000050   0x....             LDR.N    R2,??DataTable12_18
   \   00000052   0x6852             LDR      R2,[R2, #+4]
   \   00000054   0x9002             STR      R0,[SP, #+8]
   \   00000056   0x9101             STR      R1,[SP, #+4]
   \   00000058   0x9400             STR      R4,[SP, #+0]
   \   0000005A   0x....             LDR.N    R0,??DataTable12_18
   \   0000005C   0x6801             LDR      R1,[R0, #+0]
   \   0000005E   0x....             LDR.N    R0,??DataTable12_19
   \   00000060   0x.... 0x....      BL       printf
    321                gameStatus.score++;
   \   00000064   0x....             LDR.N    R0,??DataTable12_10
   \   00000066   0x6840             LDR      R0,[R0, #+4]
   \   00000068   0x1C40             ADDS     R0,R0,#+1
   \   0000006A   0x....             LDR.N    R1,??DataTable12_10
   \   0000006C   0x6048             STR      R0,[R1, #+4]
    322                printf("game score : %d\n", gameStatus.score);
   \   0000006E   0x....             LDR.N    R0,??DataTable12_10
   \   00000070   0x6841             LDR      R1,[R0, #+4]
   \   00000072   0x....             LDR.N    R0,??DataTable12_20
   \   00000074   0x.... 0x....      BL       printf
    323                
    324                if(gameStatus.score == 5){
   \   00000078   0x....             LDR.N    R0,??DataTable12_10
   \   0000007A   0x6840             LDR      R0,[R0, #+4]
   \   0000007C   0x2805             CMP      R0,#+5
   \   0000007E   0xD113             BNE.N    ??DMA1_Channel1_IRQHandler_3
    325                  SERVO_Rotate(&pwm3, 0);
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x....             LDR.N    R0,??DataTable12_6
   \   00000084   0x.... 0x....      BL       SERVO_Rotate
    326                  //SERVO_Rotate(&pwm5, 0);
    327                  delay(500);
   \   00000088   0xF44F 0x70FA      MOV      R0,#+500
   \   0000008C   0x.... 0x....      BL       delay
    328                  SERVO_Rotate(&pwm3, 30);
   \   00000090   0x211E             MOVS     R1,#+30
   \   00000092   0x....             LDR.N    R0,??DataTable12_6
   \   00000094   0x.... 0x....      BL       SERVO_Rotate
    329                  //SERVO_Rotate(&pwm5, 30);
    330                  delay(500);
   \   00000098   0xF44F 0x70FA      MOV      R0,#+500
   \   0000009C   0x.... 0x....      BL       delay
    331                  SERVO_Rotate(&pwm3, 0);
   \   000000A0   0x2100             MOVS     R1,#+0
   \   000000A2   0x....             LDR.N    R0,??DataTable12_6
   \   000000A4   0x.... 0x....      BL       SERVO_Rotate
    332                  //SERVO_Rotate(&pwm5, 0);
    333                }
    334                
    335                getDecStr(scoreResult, gameStatus.score);
   \                     ??DMA1_Channel1_IRQHandler_3: (+1)
   \   000000A8   0x....             LDR.N    R0,??DataTable12_10
   \   000000AA   0x6840             LDR      R0,[R0, #+4]
   \   000000AC   0x0001             MOVS     R1,R0
   \   000000AE   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   000000B0   0x....             LDR.N    R0,??DataTable12_21
   \   000000B2   0x.... 0x....      BL       getDecStr
    336                USART_SendData(USART2, *scoreResult);
   \   000000B6   0x....             LDR.N    R0,??DataTable12_21
   \   000000B8   0x8801             LDRH     R1,[R0, #+0]
   \   000000BA   0x....             LDR.N    R0,??DataTable12_11  ;; 0x40004400
   \   000000BC   0x.... 0x....      BL       USART_SendData
    337                
    338              }
    339              DMA_ClearITPendingBit(DMA1_IT_TC1);
   \                     ??DMA1_Channel1_IRQHandler_2: (+1)
   \   000000C0   0x2002             MOVS     R0,#+2
   \   000000C2   0x.... 0x....      BL       DMA_ClearITPendingBit
    340            }
    341          }
   \                     ??DMA1_Channel1_IRQHandler_0: (+1)
   \   000000C6   0xBD1F             POP      {R0-R4,PC}       ;; return
    342          
    343          /*
    344          void ADC1_2_IRQHandler() {
    345            if (ADC_GetITStatus(ADC1, ADC_IT_EOC) != RESET) {
    346              uint32_t adc_val = ADC_GetConversionValue(ADC1);
    347              if (adc_val < 500) {
    348                printf("Interrupt invoked2, ADC: %d\n", adc_val);
    349                
    350              }
    351              
    352              ADC_ClearITPendingBit(ADC1, ADC_IT_EOC);
    353            }
    354          }
    355          */
    356          
    357           /* ======================================================== */
    358          
    359          
    360              

   \                                 In section .text, align 2, keep-with-next
    361          void GPIO_Configure(void){
   \                     GPIO_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    362              GPIO_InitTypeDef GPIO_InitStructure;    
    363              // ???
    364              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
   \   00000002   0xF44F 0x6000      MOV      R0,#+2048
   \   00000006   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    365              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;// INPUT PULL-DOWN
   \   0000000A   0x2028             MOVS     R0,#+40
   \   0000000C   0xF88D 0x0003      STRB     R0,[SP, #+3]
    366              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x....             LDR.N    R0,??DataTable12_22  ;; 0x40011400
   \   00000014   0x.... 0x....      BL       GPIO_Init
    367          }
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
    368          

   \                                 In section .text, align 2, keep-with-next
    369          int main(){
   \                     main: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    370              printf("Init\n");
   \   00000002   0x....             LDR.N    R0,??DataTable12_23
   \   00000004   0x.... 0x....      BL       printf
    371              SystemInit();
   \   00000008   0x.... 0x....      BL       SystemInit
    372              pwm_setting();
   \   0000000C   0x.... 0x....      BL       pwm_setting
    373              BT_init(&BT);
   \   00000010   0x....             LDR.N    R0,??DataTable12_24
   \   00000012   0x.... 0x....      BL       BT_init
    374              GAME_init();
   \   00000016   0x.... 0x....      BL       GAME_init
    375              light_Init();
   \   0000001A   0x.... 0x....      BL       light_Init
    376              sensor_RCC_Configure();
   \   0000001E   0x.... 0x....      BL       sensor_RCC_Configure
    377              sensor_GPIO_Configure();
   \   00000022   0x.... 0x....      BL       sensor_GPIO_Configure
    378              sensor_ADC_Configure();
   \   00000026   0x.... 0x....      BL       sensor_ADC_Configure
    379              //sensor_NVIC_Configure();
    380              sensor_DMA_Configure();
   \   0000002A   0x.... 0x....      BL       sensor_DMA_Configure
    381              
    382              while(1) {
   \                     ??main_0: (+1)
   \   0000002E   0xE7FE             B.N      ??main_0
    383                  /*if (score > 150) {
    384                      GPIO_SetBits(GPIOE, GPIO_Pin_2);
    385                  }
    386                  GPIO_SetBits(GPIOE, GPIO_Pin_2);
    387                  //printf("adc1: %d, adc2: %d\n", ADC_Value[0], ADC_Value[1]);
    388                  delay(5000000);
    389                  GPIO_ResetBits(GPIOE, GPIO_Pin_2);*/
    390                
    391              
    392              }
    393              return 0;
                     ^
Warning[Pe111]: statement is unreachable

        printf("adc1: %d, adc2: %d, adc3: %d\nadc4: %d, adc5: %d, adc6: %d\n", ADC_Value[0], ADC_Value[1], ADC_Value[2], ADC_Value[3], ADC_Value[4], ADC_Value[5]);
        ^
"C:\Users\pnu4\Downloads\embedded_system_design-lab\PROJECT\termp_o\user\main.c",320  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement
    394          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x61 0x0A          DC8      0x61, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x62 0x0A          DC8      0x62, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x63 0x0A          DC8      0x63, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x64 0x0A          DC8      0x64, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x31 0x0A          DC8      0x31, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x32 0x0A          DC8      0x32, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x........         DC32     pwm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x........         DC32     pwm2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x........         DC32     pwm3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x........         DC32     pwm4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x........         DC32     pwm5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \   00000000   0x........         DC32     gameStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \   00000000   0x40012400         DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \   00000000   0x40020008         DC32     0x40020008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_17:
   \   00000000   0x4001244C         DC32     0x4001244c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_18:
   \   00000000   0x........         DC32     ADC_Value

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_19:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_20:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_21:
   \   00000000   0x........         DC32     scoreResult

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_22:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_23:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_24:
   \   00000000   0x........         DC32     BT

   \                                 In section .rodata, align 4
   \   00000000   0x61 0x0A          DC8 "a\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0x62 0x0A          DC8 "b\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0x63 0x0A          DC8 "c\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0x64 0x0A          DC8 "d\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x73 0x74          DC8 "start button\012"
   \              0x61 0x72    
   \              0x74 0x20    
   \              0x62 0x75    
   \              0x74 0x74    
   \              0x6F 0x6E    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x31 0x0A          DC8 "1\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \   00000000   0x32 0x0A          DC8 "2\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x61 0x64          DC8 61H, 64H, 63H, 31H, 3AH, 20H, 25H, 64H
   \              0x63 0x31    
   \              0x3A 0x20    
   \              0x25 0x64    
   \   00000008   0x2C 0x20          DC8 2CH, 20H, 61H, 64H, 63H, 32H, 3AH, 20H
   \              0x61 0x64    
   \              0x63 0x32    
   \              0x3A 0x20    
   \   00000010   0x25 0x64          DC8 25H, 64H, 2CH, 20H, 61H, 64H, 63H, 33H
   \              0x2C 0x20    
   \              0x61 0x64    
   \              0x63 0x33    
   \   00000018   0x3A 0x20          DC8 3AH, 20H, 25H, 64H, 0AH, 61H, 64H, 63H
   \              0x25 0x64    
   \              0x0A 0x61    
   \              0x64 0x63    
   \   00000020   0x34 0x3A          DC8 34H, 3AH, 20H, 25H, 64H, 2CH, 20H, 61H
   \              0x20 0x25    
   \              0x64 0x2C    
   \              0x20 0x61    
   \   00000028   0x64 0x63          DC8 64H, 63H, 35H, 3AH, 20H, 25H, 64H, 2CH
   \              0x35 0x3A    
   \              0x20 0x25    
   \              0x64 0x2C    
   \   00000030   0x20 0x61          DC8 20H, 61H, 64H, 63H, 36H, 3AH, 20H, 25H
   \              0x64 0x63    
   \              0x36 0x3A    
   \              0x20 0x25    
   \   00000038   0x64 0x0A          DC8 64H, 0AH, 0
   \              0x00         
   \   0000003B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x67 0x61          DC8 "game score : %d\012"
   \              0x6D 0x65    
   \              0x20 0x73    
   \              0x63 0x6F    
   \              0x72 0x65    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x64 0x0A    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x49 0x6E          DC8 "Init\012"
   \              0x69 0x74    
   \              0x0A 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   DMA1_Channel1_IRQHandler
        24   -> DMA_ClearITPendingBit
        24   -> DMA_GetITStatus
        24   -> SERVO_Rotate
        24   -> USART_SendData
        24   -> delay
        24   -> getDecStr
        24   -> printf
       8   GAME_end
         8   -> USART_SendData
       0   GAME_init
       8   GAME_start
         8   -> SERVO_Rotate
         8   -> delay
       8   GPIO_Configure
         8   -> GPIO_Init
       8   USART1_IRQHandler
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
         8   -> USART_SendData
       8   USART2_IRQHandler
         8   -> GAME_start
         8   -> SERVO_Rotate
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
         8   -> USART_SendData
         8   -> printf
       0   delay
      16   getDecStr
       8   main
         8   -> BT_init
         8   -> GAME_init
         8   -> SystemInit
         8   -> light_Init
         8   -> printf
         8   -> pwm_setting
         8   -> sensor_ADC_Configure
         8   -> sensor_DMA_Configure
         8   -> sensor_GPIO_Configure
         8   -> sensor_RCC_Configure
       8   pwm_setting
         8   -> SERVO_Configure
         8   -> SERVO_Rotate
      24   sensor_ADC_Configure
        24   -> ADC_Cmd
        24   -> ADC_DMACmd
        24   -> ADC_GetCalibrationStatus
        24   -> ADC_GetResetCalibrationStatus
        24   -> ADC_ITConfig
        24   -> ADC_Init
        24   -> ADC_RegularChannelConfig
        24   -> ADC_ResetCalibration
        24   -> ADC_SoftwareStartConvCmd
        24   -> ADC_StartCalibration
        24   -> printf
      56   sensor_DMA_Configure
        56   -> ADC_DMACmd
        56   -> DMA_Cmd
        56   -> DMA_DeInit
        56   -> DMA_ITConfig
        56   -> DMA_Init
        56   -> NVIC_Init
        56   -> NVIC_PriorityGroupConfig
      16   sensor_GPIO_Configure
        16   -> GPIO_Init
       8   sensor_RCC_Configure
         8   -> RCC_AHBPeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_18
       4  ??DataTable12_19
       4  ??DataTable12_2
       4  ??DataTable12_20
       4  ??DataTable12_21
       4  ??DataTable12_22
       4  ??DataTable12_23
       4  ??DataTable12_24
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ?_0
       4  ?_1
       4  ?_2
       4  ?_3
      16  ?_4
       4  ?_5
       4  ?_6
      60  ?_7
      20  ?_8
       8  ?_9
      24  ADC_Value
       2  BT
     200  DMA1_Channel1_IRQHandler
      32  GAME_end
      10  GAME_init
      58  GAME_start
      26  GPIO_Configure
      52  USART1_IRQHandler
     166  USART2_IRQHandler
      12  delay
       8  gameStatus
     102  getDecStr
       8  light_num
      48  main
       2  motor_num
      28  pwm
      28  pwm2
      28  pwm3
      28  pwm4
      28  pwm5
     368  pwm_setting
      16  scoreResult
     200  sensor_ADC_Configure
     136  sensor_DMA_Configure
      44  sensor_GPIO_Configure
      38  sensor_RCC_Configure

 
   190 bytes in section .bss
    10 bytes in section .data
   128 bytes in section .rodata
 1 608 bytes in section .text
 
 1 608 bytes of CODE  memory
   128 bytes of CONST memory
   200 bytes of DATA  memory

Errors: none
Warnings: 2
